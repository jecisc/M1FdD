|  distanceLambda averageLambda datas doc max min rand k groups grouptmp |	"To launch this code you can do CMD-A then CMD-I to inspect the result or CMD-P to print the result."		doc := 'iris.arff'.	"Name of the file. Can be square1.data or iris.arff"	k := 3.	"Number of clusters"	rand := Random seed: 5.	"Random generator"			doc := FileSystem workingDirectory / doc.				"We get all the lines of the file and we remove the ones beginning by a @, % or the empty ones."	datas := (String lf split: doc contents)		reject: [ :e | ((e beginsWith: '@') or: [ e isEmpty ]) or: [ e beginsWith: '%' ] ].					"We transforme the strings into points."	datas := datas		collect: [ :str | 			| col |			col := $, split: str.			[ col last asNumber ] "I do this to remove the class of the iris file. I could have done more generic but it is not useful for this TP."				on: Error				do: [ col removeLast ].			col collect: #asNumber ].			"We calcul the max and min for all values"	max := (1 to: datas first size) collect: [ :index | (datas collect: [ :item | item at: index ]) max ].	min := (1 to: datas first size) collect: [ :index | (datas collect: [ :item | item at: index ]) min ].				" We define lambda for the distances and the averages."	distanceLambda := [ :dist :dist2 |  ((1 to: dist size) collect: [ :ind | (((dist at: ind) - (dist2 at: ind)) / ((max at: ind) - (min at: ind))) squared ]) sum sqrt ].		averageLambda := [ :aCollection | (1 to: aCollection first size) collect: [ :ind | (aCollection collect: [ :each | each at: ind ]) average ] ].		grouptmp := OrderedDictionary new.			"We generate k different centers."	1 to: k do: [ :ind | 	grouptmp	at: ((1 to: max size) collect: [ :index | ((min at: index) to: (max at: index) by: 0.000000001) atRandom: rand ])	put: OrderedCollection new ].			[ 	groups := grouptmp copy.				"We iterate on the data and add the data to the right centers."	datas		do: [ :data | 			| minD |			"We set an initial value that will be remove by the first min."			minD := 1.1 -> nil.			groups keysDo: [ :key | minD := minD min: (distanceLambda value: key value: data) -> key ].			(groups at: minD value) add: data ].			groups values		detect: [ :e | e isEmpty ]		ifFound: [ ^ 'Un des centres n''a pas de valeure proche :( Vous pouvez essayer une autre graine ou tester sur plus de datas.' ].			grouptmp := OrderedDictionary new.			"Get the new centers"	groups valuesDo: [ :values | grouptmp at: (averageLambda value: values) put: OrderedCollection new ].	groups keys = grouptmp keys ] whileFalse.	groups keys collect: [ :center | center collect: [ :number | number round: 10   ] ]